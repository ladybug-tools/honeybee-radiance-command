"""Dctimestep command."""

from honeybee_radiance_command.options.dctimestep import DctimestepOptions
from honeybee_radiance_command._command import Command
import honeybee_radiance_command._typing as typing
import os


class Dctimestep(Command):
    """"Dctimestep command.

    Dctimestep computes annual simulation time steps via matrix-multiplication.
    Dctimestep has two invocation forms. In the first form, dctimestep is given a
    daylight coefficient specification and an optional sky vector or matrix, which
    may be read from the standard input if unspecified. The daylight coefficients
    are multiplied against these sky values and the results are written to the
    standard output. This may be a list of color values or a combined Radiance
    image, as explained below. In the second form, dctimestep takes four input
    files, forming a matrix expression. The first argument is the View matrix file
    that specifies how window output directions are related to some set of measured
    values, such as an array of illuminance points or images.

    Args:
        options: Dctimestep options. It will be set to Radiance default values if
            unspecified.
        output: Path to the output matrix file. This should not be set if the output
            file(s) has already been defined through the -o option in DctimestepOptions.
        sky_vector: Path to the input sky_vector file, generated by gendaymtx or genskyvec
            that is required for daylight coefficient, direct-daylight-coefficient
            three-phase, three-phase-direct and four-phase-direct simulations.
        sun_vector: Path to the input sun_vector file, generated by gendaymtx or genskyvec
            that is required for daylight coefficient, direct-daylight-coefficient
            three-phase, three-phase-direct and four-phase-direct simulations.
        day_coef_matrix: Path to the input daylight coefficient matrix  file, generated
            by rfluxmtx.
        sun_coef_matrix: Path to the input sun_coefficient matrix file, generated by
            rcontrib or rfluxmtx.
        view_matrix: Path to the input view matrix, created by rfluxmtx, for three-phase,
            four-phase, three-phase-direct and  four-phase-direct simulations.
        t_matrix: Path to the input t (transmission matrix) BSDF file in xml format.
        daylight_matrix: Path to the input daylight matrix, created by rfluxmtx, for
            three-phase, four-phase, three-phase-direct and  four-phase-direct +
            simulations.
        facade_matrix: Path to the input facade matrix, created by rfluxmtx, for
            four-phase and four-phase-direct simulations.

    Properties:
        * options
        * output
        * sky_vector
        * sun_vector
        * day_coef_matrix
        * sun_coef_matrix
        * facade_matrix
        * view_matrix
        * daylight_matrix
        * t_matrix

    """

    __slots__ = ('_sky_vector', '_day_coef_matrix', '_view_matrix', '_daylight_matrix',
                 '_t_matrix', '_sun_vector', '_sun_coef_matrix', '_facade_matrix')

    def __init__(self, options=None, output=None, sky_vector=None, sun_vector=None,
                 day_coef_matrix=None, sun_coef_matrix=None, view_matrix=None,
                 t_matrix=None, daylight_matrix=None, facade_matrix=None):
        """Initialize command"""
        Command.__init__(self, output=output)
        self.options = options
        self.sky_vector = sky_vector
        self.sun_vector = sun_vector
        self.day_coef_matrix = day_coef_matrix
        self.sun_coef_matrix = sun_coef_matrix
        self.view_matrix = view_matrix
        self.t_matrix = t_matrix
        self.daylight_matrix = daylight_matrix
        self.facade_matrix = facade_matrix

    @property
    def options(self):
        """dctimestep options."""
        return self._options

    @options.setter
    def options(self, value):
        if not value:
            value = DctimestepOptions()

        if not isinstance(value, DctimestepOptions):
            raise ValueError('Expected Dctimestep options not {}'.format(value))

        self._options = value

    @property
    def sky_vector(self):
        """Sky vector file that is meant for daylight coefficient and three phase
        simulations. This is typically generated by gendaymtx or genskyvec"""
        return self._sky_vector

    @sky_vector.setter
    def sky_vector(self, value):
        if value is None:
            self._sky_vector = None
        else:
            self._sky_vector = typing.normpath(value)

    @property
    def sun_vector(self):
        """Sun vector file that is meant for direct sun calculations. This is
        typically generated by gendaymtx or genskyvec"""
        return self._sun_vector

    @sun_vector.setter
    def sun_vector(self, value):
        if value is None:
            self._sun_vector = None
        else:
            self._sun_vector = typing.normpath(value)

    @property
    def day_coef_matrix(self):
        """Daylight coefficient matrix file"""
        return self._day_coef_matrix

    @day_coef_matrix.setter
    def day_coef_matrix(self, value):
        if value is None:
            self._day_coef_matrix = None
        else:
            self._day_coef_matrix = typing.normpath(value)

    @property
    def sun_coef_matrix(self):
        """Sun matrix file that is meant for direct sun calculations"""
        return self._sun_coef_matrix

    @sun_coef_matrix.setter
    def sun_coef_matrix(self, value):
        if value is None:
            self._sun_coef_matrix = None
        else:
            self._sun_coef_matrix = typing.normpath(value)

    @property
    def view_matrix(self):
        """View matrix file used for three phase and four phase simulations. Generated
        by rfluxmtx."""
        return self._view_matrix

    @view_matrix.setter
    def view_matrix(self, value):
        if value is None:
            self._view_matrix = None
        else:
            self._view_matrix = typing.normpath(value)

    @property
    def t_matrix(self):
        """Transmission matrix file that is a data-driven BSDF. Typical format is xml"""
        return self._t_matrix

    @t_matrix.setter
    def t_matrix(self, value):
        if value is None:
            self._t_matrix = None
        else:
            path, ext = os.path.splitext(value)
            if ext.lower() != '.xml':
                raise ValueError(
                    '%s does not appear to be a valid BSDF (.xml) file '
                    'that is meant for the t matrix' % value)
            self._t_matrix = typing.normpath(value)

    @property
    def daylight_matrix(self):
        """Daylight matrix file that is meant for three or four phase simulations."""
        return self._daylight_matrix

    @daylight_matrix.setter
    def daylight_matrix(self, value):
        if value is None:
            self._daylight_matrix = None
        else:
            self._daylight_matrix = typing.normpath(value)

    @property
    def facade_matrix(self):
        """Facade matrix file that is meant for four phase simulations."""
        return self._facade_matrix

    @facade_matrix.setter
    def facade_matrix(self, value):
        if value is None:
            self._facade_matrix = None
        else:
            self._facade_matrix = typing.normpath(value)

    def validate(self):
        Command.validate(self)

        # Step 1: Check if the correct group of inputs are provided.

        # Create a dictionary of valid attrib groups, the idea being that these inputs
        # belong together.
        attrib_names_group = (
            ('day_coef_matrix',), ('view_matrix', 't_matrix', 'daylight_matrix'),
            ('sun_coef_matrix',))

        attrib_values_group = [[getattr(self, attr) for attr in attr_grp] for attr_grp in
                               attrib_names_group]

        valid_attrib_groups = [all(attr_grp) for attr_grp in attrib_values_group]

        incomp_attrib_groups = [any(attr_grp) for attr_grp in attrib_values_group]

        # ensure that one, and only one input group has all the valid inputs.
        if valid_attrib_groups.count(True) != 1:
            attrib_groups = [str(attrib_names_group[idx]) for idx, value
                             in enumerate(valid_attrib_groups) if value is True]

            error_msg = 'Only one of the following input groups must' \
                        ' be provided: %s.Currently all of them have ' \
                        'been provided.' % (', '.join(attrib_groups))

            raise ValueError(error_msg)

        # ensure that there are no orphan groups with missing entries.
        # This test exists because the error won't get caught in the previous test and
        # there is potential for confusion if unrelated inputs are provided.
        if incomp_attrib_groups.count(True) != 1:
            attrib_groups = [str(attrib_names_group[idx]) for idx, value
                             in enumerate(incomp_attrib_groups) if value is True]

            error_msg = 'All of these groups contain inputs: %s. Only one input group ' \
                        'can be specified at a time' % (', '.join(attrib_groups))

            raise ValueError(error_msg)

        if self.day_coef_matrix or self.view_matrix:
            assert self.sky_vector, 'Since the dc or view matrix are provided, ' \
                                    'the sky vector (%s) needs to be provided as ' \
                                    'well.' % self.sky_vector
        else:
            assert self.sun_vector, 'Since the sun matrix has been provided, the sun ' \
                                    'vector(%s) needs to be provided as ' \
                                    'well.' % self.sun_vector

        # Step 2: Ensure that the output is not specified in two different ways.
        if self.options.o and self.output:
            raise Exception('The output has been specified using the "output" attribute'
                            ' as well as the "o"(i.e. -o) option. Only one of these '
                            'options can be specified at a time. ')

    def to_radiance(self, stdin_input=False):
        """Command in Radiance format."""
        self.validate()

        command_parts = [self.command, self.options.to_radiance()]

        # The validation checks will ensure that the correct inputs are set.
        if self.day_coef_matrix:
            command_parts.extend([self.day_coef_matrix, self.sky_vector])
        if self.sun_coef_matrix:
            command_parts.extend([self.sun_coef_matrix, self.sun_vector])
        if self.view_matrix:
            command_parts.extend([self.view_matrix, self.t_matrix] +
                                 [self.facade_matrix] if self.facade_matrix else [] +
                                 [self.daylight_matrix,self.sky_vector])

        cmd = ' '.join(command_parts)

        if self.pipe_to:
            cmd = ' | '.join((cmd, self.pipe_to.to_radiance(stdin_input=True)))
        elif self.output:
            cmd = ' > '.join((cmd, self.output))

        return ' '.join(cmd.split())
